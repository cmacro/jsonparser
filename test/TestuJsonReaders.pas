unit TestuJsonReaders;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, Classes, SysUtils, uJsonReaders, Windows;

type
  // Test methods for class TTestdata

  TestTJsonReader = class(TTestCase)
  private
    procedure WriteArray(level: integer; const s: string; Idx, len: Integer);
    procedure WriteJsonObj(level: integer; const s: string; Idx, len: Integer);
  public
  published
    procedure TestDefault;
  end;

implementation

uses
  JsonDataObjects, TypInfo;

  function GetIndent(l: integer): string;
  var I: Integer;
  begin
    l := l * 2;
    SetLength(Result, l);
    for I := 1 to l do
      Result[i] := ' ';
  end;

procedure TestTJsonReader.WriteArray(level: integer; const s: string; Idx, len: Integer);
var
  c: Char;
  k: TJSONReaderKind;
  parser: TJSONReader;
begin
//  Writeln(GetIndent(level) + 'read array');
//  Writeln(GetIndent(level) + '--------------------------');


  parser.Init(s, idx, len);
  Check(parser.GetNextNonWhiteChar = '[');

  while true do
  begin
    k := parser.GetNext;
    if k = jrkNone then Break;

//    Write(GetIndent(level) +  'Type: ' + GetEnumName(TypeInfo(TJSONReaderKind), ord(k)));
//    if not (k in [kArray, kObject, kTrue, kFalse, kNull]) then
//      Writeln('  token: ' + parser.GetToken);

    if k = jrkArray then
      WriteArray(level + 1, parser.JSON, parser.TokenIdx, parser.TokenLen)
    else if k = jrkObject then
      WriteJsonObj(level + 1, parser.JSON, parser.TokenIdx, parser.TokenLen);

    c := parser.GetNextNonWhiteChar;
    Check((c = ',') or (c = #0) or (c = ']'));
  end;

end;

procedure TestTJsonReader.WriteJsonObj(level: integer; const s: string; Idx, len: Integer);
var
  bIsID: Boolean;
  cTok: Char;
  k: TJSONReaderKind;
  parser: TJSONReader;
begin
//  Writeln(GetIndent(level) + 'read object');
//  Writeln(GetIndent(level) + '--------------------------');

  parser.Init(s, idx, len);
  Check(parser.GetNextNonWhiteChar = '{');

  bIsID := True;
  while true do
  begin
    k := parser.GetNext;
    if k = jrkNone then Break;

//    Write(GetIndent(level) +  'Type: ' + GetEnumName(TypeInfo(TJSONReaderKind), ord(k)));
//    if not (k in [kArray, kObject, kTrue, kFalse, kNull]) then
//      Writeln('  token: ' + parser.GetToken);

    if k = jrkArray then
      WriteArray(level + 1, parser.JSON, parser.TokenIdx, parser.TokenLen)
    else if k = jrkObject then
      WriteJsonObj(level + 1, parser.JSON, parser.TokenIdx, parser.TokenLen);

    if bIsID  then
    begin
      Check(parser.GetNextNonWhiteChar = ':');
      bIsID := False;
    end
    else
    begin
      cTok := parser.GetNextNonWhiteChar;
      Check((cTok = ',') or (ctok = #0) or (ctok = '}'));
      bIsID := true;
    end;
  end;
end;

procedure TestTJsonReader.TestDefault;
var
  bIsID: Boolean;
  cstr: TStringStream;
  cTok: Char;
  iTickCount: Cardinal;
  k: TJSONReaderKind;
  parser: TJSONReader;
  s: string;
  I: Integer;
  iSize: Integer;
begin
  parser.Init('{}', 1, -1);
  Check(not parser.GetNextString, 'ø’Json∂¡»°¥ÌŒÛ');

  Writeln('');
  parser.Init('{"abc": "abc"}', 1, -1);
  while parser.GetNextString do
    Writeln(parser.GetToken);

  parser.Init('{"abc": 1}', 1, -1);
  while parser.GetNextString do
    Writeln(parser.GetToken);


  s := '{"abc": 1,"arr": [1,true,"3", {}, []], "data": {"name": "test" }, "arr": [1,true,"3", {}, []], "Code": 200}';
  Writeln('Parser Json Obj: ' + s);
  parser.Init(s, 1, -1);
  check(parser.GetNextNonWhiteChar = '{');

  bIsID := True;
  while true do
  begin
    k := parser.GetNext;
    if k = jrkNone then Break;


    Write('Type: ' + GetEnumName(TypeInfo(TJSONReaderKind), ord(k)));
    if not (k in [jrkArray, jrkObject, jrkTrue, jrkFalse, jrkNull]) then
      Writeln('  token: ' + parser.GetToken);

    if k = jrkArray then
      WriteArray(1, parser.JSON, parser.TokenIdx, parser.TokenLen)
    else if k = jrkObject then
      WriteJsonObj(1, parser.JSON, parser.TokenIdx, parser.TokenLen);

    if bIsID  then
    begin
      Check(parser.GetNextNonWhiteChar = ':');
      bIsID := False;
    end
    else
    begin
      cTok := parser.GetNextNonWhiteChar;
      Check((cTok = ',') or (ctok = #0) or (ctok = '}'));
      bIsID := true;
    end;
  end;

  Writeln('read big file ...');
  cstr := TStringStream.Create.Create('', TEncoding.UTF8);
  cstr.LoadFromFile('.\data\bpProducts.json');
  s := cstr.DataString;
  iSize := Length(s);
  cstr.Free;

  iTickCount := GetTickCount;
  for I := 1 to 3 do
    WriteJsonObj(1, s, 1, -1);
  iTickCount := GetTickCount - iTickCount;
  Writeln(format('TickCount read %d size: %d count: %d/%d', [3, iSize, iTickCount div 3, iTickCount]));

end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTJsonReader.Suite);
end.

