unit TestuJsonReaders;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, Classes, SysUtils, uJsonReaders, Windows, JsonDataObjects;

type
  TTestTJSONPCharReader = class(TTestCase)
  private
    function CheckObjectJson(s: PChar; len: LongInt; var msg: string): boolean;
    function CheckArrayJson(s: PChar; len: LongInt; var msg: string): boolean;
    function CheckNodeItem(k: TJSONReaderKind; const sfieldName: string; var r:
        TJSONReader; cJsonObj: TJsonObject; var msg: string): boolean;
  public
    function CheckCompareData(const data: string; var msg: string): Boolean;
    function CheckCompareFile(const fn: string; var msg: string): Boolean;
  published
    procedure TestDefault;
    procedure TestReader;
    procedure TestBigFile;

  end;

function kToBool(k: TJSONReaderKind): boolean;




implementation

uses
  TypInfo;

  function GetIndent(l: integer): string;
  var I: Integer;
  begin
    l := l * 2;
    SetLength(Result, l);
    for I := 1 to l do
      Result[i] := ' ';
  end;



procedure ReadFileData(const fn: string; var data: string);
var
  cFile: TStringStream;
begin
  cFile := TStringStream.Create('', TEncoding.UTF8);
  try
    cFile.LoadFromFile(fn);
    data := cFile.DataString;
  finally
    cFile.Free;
  end;
end;



function JsonToStr(const src: string): string;
begin

end;

function kToBool(k: TJSONReaderKind): boolean;
begin
  if k = jrkFalse then result := False
  else result := True;
end;


function TTestTJSONPCharReader.CheckArrayJson(s: PChar; len: LongInt; var msg:
    string): boolean;
var
  bSucc: Boolean;
  c: Char;
  iIdx: Integer;
  k: TJSONReaderKind;
  r: TJSONReader;
  cJsonObj: TJsonArray;
  Current: Integer;
  jt: TJsonDataType;
  sNewData: string;

  procedure SetMsg(const s: string);
  begin
    msg := format('Index: %d -> %d %s', [Current, r.Curr - r.JSON, s]);
  end;

begin
 Result := False;
 if len <= 0 then
  len := length(s);
  r.init(s,len);
  k := r.GetDataType;
  if k <> jrkArray then
    Exit;

  cJsonObj := TJsonArray.Create;
  try
    SetString(sNewData, s, len);
    cJsonObj.FromJSON(sNewData);

    Current := -1;
    while True do
    begin
      inc(Current);
      iIdx := r.Curr - r.JSON;
      k := r.GetNext;
      jt := jdtNone;
      if k <> jrkNone then
        jt := cJsonObj.Types[Current];

      case k of
        jrkNone: begin
                  if (cJsonObj.Count = Current) then Break;
                  SetMsg('field not value'); Exit;
                end;
        jrkNull: begin
                  if ((jt = jdtObject) and (cJsonObj.Items[Current].ObjectValue <> nil)) then
                  begin
                    SetMsg('Field types None are inconsistent'); Exit;
                  end;
                  if not (jt  in [jdtObject,jdtNone]) then
                  begin
                    SetMsg('Field types None are inconsistent'); Exit;
                  end;
                 end;
        jrkFalse,
        jrkTrue :begin
                  if jt <> jdtBool then
                  begin
                    SetMsg('Field types boolean are inconsistent'); Exit;
                  end;
                  if cJsonObj.B[Current] <> kToBool(k) then
                  begin
                    SetMsg('Field value are inconsistent'); Exit;
                  end;
                 end ;
        jrkString: begin
                  if jt <> jdtString then
                  begin
                    SetMsg('Field types string are inconsistent'); Exit;
                  end;
                  if not SameText(r.GetToStrToken, cJsonObj.S[Current]) then
                  begin
                    SetMsg('Field value '+ cJsonObj.S[Current] +' are inconsistent'); Exit;
                  end;
                 end;
        jrkNumber:  begin
                  if not (jt in [jdtInt, jdtLong, jdtULong, jdtFloat]) then
                  begin
                    SetMsg('Field types kNumber are inconsistent'); Exit;
                  end;
                  if not SameText(r.GetToken, cJsonObj.S[Current]) then
                  begin
                    bSucc := False;
                    case jt of
                      jdtInt    : bSucc := r.AsInt = cJsonObj.I[Current];
                      jdtLong   : bSucc := r.AsInt64 = cJsonObj.L[Current];
                      jdtULong  : bSucc := r.AsUInt64 = cJsonObj.U[Current];
                      jdtFloat  : bSucc := SameStr(FloatToStr(r.AsFloat), cJsonObj.S[Current]);
                    end;
                    if not bSucc then
                    begin
                      SetMsg('Field value '+ cJsonObj.S[Current] +' are inconsistent');
                      Exit;
                    end;
                  end;
                 end;
        jrkObject: begin
                  if cJsonObj.Types[Current] <> jdtObject then
                  begin
                    SetMsg('Field types string are inconsistent'); Exit;
                  end;
                  if not CheckObjectJson(r.Token, r.TokenLen, msg) then
                  begin
                    msg := format('Index: %d, Current: %d %s', [iIdx, Current, msg]); // InttoStr() +'  ' + msg;
                    Exit;
                  end;
                 end;
        jrkArray: begin
                  if cJsonObj.Types[Current] <> jdtArray then
                  begin
                    SetMsg('Field types string are inconsistent'); Exit;
                  end;
                  if not CheckArrayJson(r.Token, r.TokenLen, msg) then
                  begin
                    msg := format('Index: %d, Current: %d %s', [iIdx, Current, msg]);
                    Exit;
                  end;
                 end;
        else
        begin
          SetMsg('unknown type'); Exit;
        end;
      end;

      c := r.GetNextNonWhiteChar;
      if not ((c = ',') or (c = #0) or (c = ']')) then
      begin
        SetMsg('the value is not over');
        Exit;
      end;

      if (c = #0) or (c = ']') then
        Break;
    end;
  finally
    cJsonObj.Free;
  end;

  Result := True;

end;

function TTestTJSONPCharReader.CheckCompareData(const data: string; var msg:
    string): Boolean;
var
  k: TJSONReaderKind;
  rReader: TJSONReader;
begin
  rReader.Init(PChar(data), -1);
  k := rReader.GetDataType;
  if k = jrkObject then
    Result := CheckObjectJson(PChar(data), -1, msg)
  else if k = jrkArray then
    Result := CheckArrayJson(PChar(data), -1, msg)
  else
  begin
    msg := 'unknown value';
    Result := False;
  end;
end;

function TTestTJSONPCharReader.CheckCompareFile(const fn: string; var msg:
    string): Boolean;
var
  s: string;
begin
  ReadFileData(fn, s);
  Result := CheckCompareData(s, msg);
end;

function TTestTJSONPCharReader.CheckNodeItem(k: TJSONReaderKind; const
    sfieldName: string; var r: TJSONReader; cJsonObj: TJsonObject; var
    msg: string): boolean;

  procedure SetMsg(const s: string);
  var
    d: string;
  begin
    //if iidx < r.CurIdx then
    SetString(d, r.Curr, 10);// := Copy(r.JSON, iIdx, r.CurIdx - iIdx)
    //else  d := '';
    msg := format('Index: %s', [d]);
  end;
var
  bSucc: Boolean;
  jt: TJsonDataType;
begin
  Result := False;
  jt := cJsonObj.Types[sFieldName];
  case k of
    jrkNone: begin  SetMsg('field not value'); Exit; end;
    jrkNull: begin
              if (jt = jdtObject) and (cJsonObj.O[sFieldName] = nil ) then
              begin
                Result := true;
                Exit;
              end;

              if cJsonObj.Types[sFieldName] <> jdtNone then
              begin
                SetMsg('Field types None are inconsistent'); Exit;
              end;

             end;
    jrkFalse,
    jrkTrue :begin
              if cJsonObj.Types[sFieldName] <> jdtBool then
              begin
                SetMsg('Field types boolean are inconsistent'); Exit;
              end;
              if cJsonObj.B[sFieldName] <> kToBool(k) then
              begin
                SetMsg('Field value are inconsistent'); Exit;
              end;
             end ;
    jrkString: begin
              if cJsonObj.Types[sFieldName] <> jdtString then
              begin
                SetMsg('Field types string are inconsistent'); Exit;
              end;
              if not SameText(r.GetToStrToken, cJsonObj.S[sFieldName]) then
              begin
                SetMsg('Field value '+ cJsonObj.S[sFieldName] +' are inconsistent'); Exit;
              end;
             end;
    jrkNumber:  begin
              if not (cJsonObj.Types[sFieldName] in [jdtInt, jdtLong, jdtULong, jdtFloat]) then
              begin
                SetMsg('Field types kNumber are inconsistent'); Exit;
              end;

              if not SameText(r.GetToken, cJsonObj.S[sFieldName]) then
              begin
                bSucc := False;
                case jt of
                  jdtInt    : bSucc := r.AsInt = cJsonObj.I[sfieldName];
                  jdtLong   : bSucc := r.AsInt64 = cJsonObj.L[sfieldName];
                  jdtULong  : bSucc := r.AsUInt64 = cJsonObj.U[sfieldName];
                  jdtFloat  : bSucc := SameStr(FloatToStr(r.AsFloat), cJsonObj.S[sfieldName]);
                end;
                if not bSucc then
                begin
                  SetMsg('Field value '+ cJsonObj.S[sFieldName] +' are inconsistent'); Exit;
                end;
              end;
             end;
    jrkObject: begin
              if cJsonObj.Types[sFieldName] <> jdtObject then
              begin
                SetMsg('Field types string are inconsistent'); Exit;
              end;
              if not CheckObjectJson(r.Token, r.TokenLen, msg) then
                Exit;
             end;
    jrkArray: begin
              if cJsonObj.Types[sFieldName] <> jdtArray then
              begin
                SetMsg('Field types string are inconsistent'); Exit;
              end;
              if not CheckArrayJson(r.Token, r.TokenLen, msg) then
                Exit;
             end;
    else
    begin
      SetMsg('unknown type'); Exit;
    end;
  end;

  Result := True;

end;

function TTestTJSONPCharReader.CheckObjectJson(s: PChar; len: LongInt; var msg:
    string): boolean;
var
  c: Char;
  cJsonObj: TJsonObject;
  k: TJSONReaderKind;
  rReader: TJSONReader;
  sFieldName: string;
  sNewData: string;

  procedure SetMsg(const s: string);
  var
    d: string;
  begin
    SetString(d, rReader.Curr, 10);
    msg := Format(' fieldname: %s Index:  %s', [sFieldName, d]);
  end;

begin
  Result := False;
  if len <= 0 then
    len := length(s);

  rReader.Init(s, len);
  k := rReader.GetDataType;
  if k <> jrkObject then
    Exit;

  sFieldName := '';
  cJsonObj := TJsonObject.Create;
  try
    SetString(sNewData, s, len);
    cJsonObj.FromJSON(sNewData);

    while True do
    begin
      k := rReader.GetNext;
      if (k = jrkNone) and (cJsonObj.Count = 0) then
        Break;

      if k = jrkNone then
      begin
        SetMsg('read object error ' + sNewData);
        Exit;
      end;

      if k <> jrkString then
      begin
        SetMsg('read field name');
        Exit;
      end;
      if rReader.GetNextNonWhiteChar <> ':' then
      begin
        SetMsg('The field is not over');
        Exit;
      end;

      sFieldName := rReader.GetToStrToken;
      k :=  rReader.GetNext;
      if not CheckNodeItem(k, sFieldName, rReader, cJsonObj, msg) then
        Exit;

      c := rReader.GetNextNonWhiteChar;
      if not ((c = ',') or (c = #0) or (c = '}')) then
      begin
        SetMsg('the value is not over');
        Exit;
      end;

      if (c = #0) or (c = '}') then
      begin
        Break;
      end;

    end;
  finally
    cJsonObj.Free;
  end;

  Result := True;

end;

{ TTestTJSONPCharReader }

procedure TTestTJSONPCharReader.TestBigFile;
begin

//  cStr := TStringStream.Create('', TEncoding.UTF8);
//  try
//    cStr.LoadFromFile('.\data\bpProducts.json');
//    LChars := TEncoding.UTF8.GetChars(cStr.Bytes);
//  finally
//    cStr.Free;
//  end;


    //s := cStr.DataString; // cStr.DataString TStringBuilder.Create;

//    r.Init(PChar(LChars), -1);
//    r.GetDataType;



//  Check(CheckCompareFile('.\data\bpProducts.json', msg), 'parser bpProducts.json file：' + msg);
//  iTick := GetTickCount - iTick;
//  Writeln('   tickcount :' + inttostr(iTick));

end;

procedure TTestTJSONPCharReader.TestDefault;
var
  parser: TJSONReader;
  s: string;

  procedure SetParserStr(const d: string);
  begin
    s := d;
    parser.Init(PChar(s), -1);
  end;

begin
  SetParserStr('{}');
  Check(parser.GetNextNonWhiteChar = '{', 'Is empty object');
  Check(parser.GetNext = jrkNone, 'Is empty object');

  SetParserStr('{"hex": "\u4e2d\u6587\u6d4b\u8bd5", "abc": 1}');
  check(parser.GetDataType = jrkObject, 'Read Json data type, should be Object');
  check(parser.GetNext = jrkString, 'Read attribute name');
  Check(parser.GetToken = 'hex');

  Check(parser.GetNextNonWhiteChar = ':');
  check(parser.GetNext = jrkString);
  Check(parser.GetToken = '\u4e2d\u6587\u6d4b\u8bd5', 'read token err');
  Check(parser.AsStr = '中文测试');

  SetParserStr('{"hex": "\u4e2d\u6587\u6d4b\u8bd5", "abc": 1}');
  parser.GetDataType;
  Check(parser.GetNextOf('abc') = jrkNumber);
  Check(parser.AsInt = 1);


end;

procedure TTestTJSONPCharReader.TestReader;
var
  iTick: Cardinal;
  msg: string;
begin
  Writeln(' TJSONReader passes json file');
  iTick := GetTickCount;
  Check(CheckCompareFile('.\passes\1.json', msg), 'parser passes 1.json file：' + msg);
  Check(CheckCompareFile('.\passes\2.json', msg), 'parser passes 2.json file：' + msg);
  Check(CheckCompareFile('.\passes\3.json', msg), 'parser passes 3.json file：' + msg);
  iTick := GetTickCount - iTick;
  Writeln('   tickcount :' + inttostr(iTick));

end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TTestTJSONPCharReader.Suite);
end.

